#SRP  #ЕдинаяОтветственность  #Программирование  #SOLID  #ООП  #ЧитаемостьКода  #Тестирование  #Гибкость  #ЛокализацияИзменений  #Декомпозиция  #Код  #Разработка  #Методология  #КритерииСамопроверки  #ОккамаFirst  #ПринципыПрограммирования  #АрхитектураПрограммногоОбеспечения  #ЧистыйКод  #УправлениеСложностью  #ПрограммнаяИнженерия
### Определение 1. Единая ответственность (SRP)

Принцип единой ответственности (Single Responsibility Principle, SRP) утверждает, что у каждого объекта должна быть только одна причина для изменения, то есть он должен нести одну ответственность.

#### Пример: Выпивоха (Tippler)

Для иллюстрации SRP можно рассмотреть объект "Выпивоха", который выполняет три основные операции:

1. **Налить** (PourOperation)
2. **Выпить** (DrinkUpOperation)
3. **Закусить** (TakeBiteOperation)

Каждая из этих операций отвечает за свою часть процесса, что позволяет избежать перегрузки одного класса.

```csharp
class Tippler {
    void Act() {
        _pourOperation.Do(); // налить
        _drinkUpOperation.Do(); // выпить
        _takeBiteOperation.Do(); // закусить
    }
}
```

#### Зачем это нужно?

- **Читаемость кода**: Код становится более понятным и структурированным.
- **Командная работа**: Несколько программистов могут работать над разными частями кода одновременно.
- **Тестирование**: Простые элементы легче тестировать.
- **Гибкость**: Легче создавать новые комбинации операций.

#### Минусы:

- Увеличение количества классов.
- Возможная задержка в выполнении операций.

### Определение 2. Единая изменчивость

Второе определение SRP гласит, что у модуля должен быть только один повод для изменения. Это означает, что изменения в одной части системы не должны затрагивать другие части.

#### Пример: Две реализации выпивохи

1. **Декомпозированная версия** (с тремя классами).
2. **Монолитная версия** (вся логика в одном методе Act).

```csharp
class BrutTippler {
    void Act() {
        // Логика наливания, выпивания и закусывания
    }
}
```

Обе версии выполняют одну и ту же ответственность, но первая позволяет легче вносить изменения.

### Определение 3. Локализация изменений

При добавлении логирования в операции, важно, чтобы изменения касались только одной части кода. Например, если мы добавляем логирование в PourOperation, то логика логирования также должна быть изолирована.

#### Пример: Логирование

```csharp
class PourOperation: IOperation {
    void Do() {
        _log.Log($"Before pour");
        // Логика наливания
        _log.Log($"After pour");
    }
}
```

Если логирование становится изменчивым, его следует выделить в отдельный класс, но не дробить его на слишком много частей.

### Формализм 1. Определение SRP

- Каждый элемент должен быть ответственен за что-то одно.
- Ответственность — это повод для изменения.
- Изменения должны быть локализованы.

### Формализм 2. Критерии самопроверки

1. Четкое определение назначения класса/метода.
2. Минимальное количество затрагиваемых файлов при изменениях.
3. Минимизация конфликтов при совместной работе.
4. Легкость в нахождении информации о бизнес-логике.
5. Понятные названия классов и методов.

### Формализм 3. Методика разработки "Оккама-first"

- Ошибаться лучше в большую сторону: не дробите, если не уверены.
- Сложнее собирать из осколков, чем делить на части.

### Заключение

SRP применим не только в ООП, но и в других областях разработки. Он помогает контролировать сложные системы, обеспечивая гибкость и эффективность. Принцип SRP — это способ упрощения и структурирования кода, что делает его более понятным и управляемым.